import json
import re
from datetime import datetime

def dump_numeric(value, typename: str):
  s = str(value)
  if s.find('.') >= 0:
    s += 'f'
  elif typename == 'float':
    s += '.f'
  return s

# rules to generate variable names (public data members)
# Camel Case
def dump_var_name(json_field: str):
  json_field = json_field[0].lower() + json_field[1:]
  return re.sub('(_[a-z])', lambda m: m.group(1)[1].upper(), json_field)

# rules to generate class names (public data members)
# Camel Case
def dump_class_name(json_field:str):
  json_field = json_field[0].upper() + json_field[1:]
  return re.sub('(_[a-z])', lambda m: m.group(1)[1].upper(), json_field)

# inline void FromJson(const rapidjson::Value& json, Units& units) {
#   FromJson(json['archer'], units.archer);
#   FromJson(json['warrior'], units.warrior);
# }

# inline void FromJson(const rapidjson::Value& json, Archer& archer) {
#   archer.health = json['health'].asInt32();
#   archer.dragonbones = json['dragonbones'].asString();
#   FromJson(json['weapons'], archer.weapons);
#   ....
# }

# def dump_fromjson_func(buffer: str, scopes: list):
#   typename = '::'.join(scopes)
#   variable = dump_var_name(scopes[-1])
#   template = 'inline void FromJson(const std::string& json, {type}& {variable}) {{\n'

def generate(obj, depth: int, scopes: list, structs: list[list[tuple]], ostream):
  PREFIX = depth * '  '

  if isinstance(obj, dict):
    for key in obj:
      if isinstance(obj[key], dict):
        # open class declaration
        print('{}struct {} {{'.format(PREFIX, dump_class_name(key)), file = ostream)
        # add dict
        structs += [[]]
        scopes += [ dump_class_name(key) ]
        generate(obj[key], depth + 1, scopes, structs, ostream)
        typename = '::'.join(scopes)
        scopes.pop()
        struct = structs.pop()
        # close class declaration
        if depth != 1:
          print('{}}} {};'.format(PREFIX, dump_var_name(key)), file = ostream)
          structs[-1] += [(typename, dump_var_name(key))]
        else:
          print('{}}};'.format(PREFIX), file = ostream)
        print('{} {{\n{} \n}}'.format(typename, struct))
      elif isinstance(obj[key], str):
        # declare string variable
        print('{}std::string {} = "{}";'.format(PREFIX
            , dump_var_name(key)
            , obj[key])
          , file = ostream)
        structs[-1] += [('std::string', dump_var_name(key))]
      elif isinstance(obj[key], list):
        array_len = len(obj[key])
        assert array_len > 0, "Wrong JSON sample: empty list as input"
        element_typename = type(obj[key][0]).__name__
        elements = ', '.join([ dump_numeric(x, element_typename) for x in obj[key]])
        # declare array variable
        print('{}std::array<{type}, {size}> {variable} = {{ {values} }};'
          .format(PREFIX
              , type = element_typename
              , size = array_len
              , variable = dump_var_name(key)
              , values = elements)
            , file = ostream)
        structs[-1] += [('std::array<{}, {}>'.format(element_typename, array_len), dump_var_name(key))]
      else:
        type_name = type(obj[key]).__name__
        # declare float/int variable 
        print('{}{} {} = {};'.format(PREFIX
            , type_name
            , dump_var_name(key)
            , dump_numeric(obj[key], type_name))
          , file = ostream)
        structs[-1] += [(type_name, dump_var_name(key))]


data = {}
with open('db.json', 'r') as istream:
  data = json.load(istream)

template = '// This file is auto generated by script\n// Date: {}\n'

rapidjson_header = ('#include "rapidjson/document.h"\n' + 
  '#include "rapidjson/writer.h"\n' + 
  '#include "rapidjson/stringbuffer.h"\n')

includes = ('#include <string>\n' + 
  '#include <array>\n\n')

with open('generated.hpp', 'w') as ostream:
  print(template.format(datetime.now().strftime("%d/%m/%Y %H:%M:%S")), file = ostream)
  print(includes, file = ostream)
  print('namespace json_autogenerated_classes {\n', file = ostream)
  a = []
  b = []
  generate(data, 1, a, b, ostream)
  print('\n} // namespace json_autogenerated_classes', file = ostream)